"""
CLI interface for the Melee Decomp Agent tooling.

Commands:
- extract: List and extract unmatched functions
- scratch: Manage decomp.me scratches
- claim: Manage function claims for parallel agents
- complete: Track completed functions
- compilers: List available compilers
- commit: Commit matched functions and create PRs
- docker: Manage local decomp.me instance
"""

import asyncio
import fcntl
import json
import os
import re
import time
from pathlib import Path
from typing import Annotated, Any, Optional

from dotenv import load_dotenv

# Load .env from project root (gitignored, contains local config like DECOMP_API_BASE)
load_dotenv(Path(__file__).parent.parent / ".env")

import typer
from rich.console import Console
from rich.table import Table

# File paths for coordination (same as MCP server)
# Per-agent isolation via DECOMP_AGENT_ID env var
_agent_id = os.environ.get("DECOMP_AGENT_ID", "")
_agent_suffix = f"_{_agent_id}" if _agent_id else ""

# Claims and completed are SHARED across agents (coordination)
DECOMP_CLAIMS_FILE = os.environ.get("DECOMP_CLAIMS_FILE", "/tmp/decomp_claims.json")
DECOMP_COMPLETED_FILE = os.environ.get("DECOMP_COMPLETED_FILE", "/tmp/decomp_completed.json")
DECOMP_CLAIM_TIMEOUT = int(os.environ.get("DECOMP_CLAIM_TIMEOUT", "3600"))  # 1 hour

# Tokens are PER-AGENT (each agent owns different scratches)
DECOMP_SCRATCH_TOKENS_FILE = os.environ.get("DECOMP_SCRATCH_TOKENS_FILE", f"/tmp/decomp_scratch_tokens{_agent_suffix}.json")


def _load_scratch_tokens() -> dict[str, str]:
    """Load scratch claim tokens from file."""
    tokens_path = Path(DECOMP_SCRATCH_TOKENS_FILE)
    if not tokens_path.exists():
        return {}
    try:
        with open(tokens_path, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}


def _save_scratch_token(slug: str, token: str) -> None:
    """Save a scratch claim token."""
    tokens = _load_scratch_tokens()
    tokens[slug] = token
    tokens_path = Path(DECOMP_SCRATCH_TOKENS_FILE)
    tokens_path.parent.mkdir(parents=True, exist_ok=True)
    with open(tokens_path, 'w') as f:
        json.dump(tokens, f, indent=2)

app = typer.Typer(
    name="melee-agent",
    help="Agent tooling for contributing to the Melee decompilation project",
)
console = Console()

# Default paths
DEFAULT_MELEE_ROOT = Path(__file__).parent.parent / "melee"
# DECOMP_API_BASE is required - no default to avoid committing local IPs
_api_base = os.environ.get("DECOMP_API_BASE", "")
if not _api_base:
    DEFAULT_DECOMP_ME_URL = ""
else:
    # Strip /api suffix if present (e.g., http://host/api -> http://host)
    DEFAULT_DECOMP_ME_URL = _api_base[:-4] if _api_base.endswith("/api") else _api_base
# Context file for scratch creation (generated by m2ctx.py in melee build)
_context_env = os.environ.get("DECOMP_CONTEXT_FILE", "")
DEFAULT_CONTEXT_FILE = Path(_context_env) if _context_env else DEFAULT_MELEE_ROOT / "build" / "ctx.c"


def _require_api_url(api_url: str) -> None:
    """Validate that API URL is configured, exit with helpful error if not."""
    if not api_url:
        console.print("[red]Error: DECOMP_API_BASE environment variable is required[/red]")
        console.print("[dim]Set it to your decomp.me instance URL, e.g.:[/dim]")
        console.print("[dim]  export DECOMP_API_BASE=https://decomp.me[/dim]")
        raise typer.Exit(1)


# ============================================================================
# Extract Commands
# ============================================================================

extract_app = typer.Typer(help="Extract and list unmatched functions")
app.add_typer(extract_app, name="extract")


@extract_app.command("list")
def extract_list(
    melee_root: Annotated[
        Path, typer.Option("--melee-root", "-m", help="Path to melee submodule")
    ] = DEFAULT_MELEE_ROOT,
    min_match: Annotated[
        float, typer.Option("--min-match", help="Minimum match percentage")
    ] = 0.0,
    max_match: Annotated[
        float, typer.Option("--max-match", help="Maximum match percentage")
    ] = 0.99,
    min_size: Annotated[
        int, typer.Option("--min-size", help="Minimum function size in bytes")
    ] = 0,
    max_size: Annotated[
        int, typer.Option("--max-size", help="Maximum function size in bytes")
    ] = 10000,
    limit: Annotated[
        int, typer.Option("--limit", "-n", help="Maximum number of results")
    ] = 20,
    include_completed: Annotated[
        bool, typer.Option("--include-completed", help="Include already-completed functions")
    ] = False,
):
    """List unmatched functions from the melee project.

    By default, excludes functions already tracked as completed/attempted.
    Use --include-completed to show all functions.
    """
    from src.extractor import extract_unmatched_functions

    result = asyncio.run(extract_unmatched_functions(melee_root))

    # Load completed functions to exclude
    completed = set()
    if not include_completed:
        completed_path = Path(DECOMP_COMPLETED_FILE)
        if completed_path.exists():
            try:
                with open(completed_path, 'r') as f:
                    completed = set(json.load(f).keys())
            except (json.JSONDecodeError, IOError):
                pass

    # Filter and limit functions
    functions = [
        f for f in result.functions
        if min_match <= f.current_match <= max_match
        and min_size <= f.size_bytes <= max_size
        and f.name not in completed
    ]
    functions = sorted(functions, key=lambda f: -f.current_match)[:limit]

    table = Table(title="Unmatched Functions")
    table.add_column("Name", style="cyan")
    table.add_column("File", style="green")
    table.add_column("Match %", justify="right")
    table.add_column("Size", justify="right")
    table.add_column("Address", style="dim")

    for func in functions:
        table.add_row(
            func.name,
            func.file_path,
            f"{func.current_match * 100:.1f}%",
            f"{func.size_bytes}",
            func.address,
        )

    console.print(table)
    excluded_msg = f", {len(completed)} completed excluded" if completed else ""
    console.print(f"\n[dim]Found {len(functions)} functions (from {result.total_functions} total{excluded_msg})[/dim]")


@extract_app.command("get")
def extract_get(
    function_name: Annotated[str, typer.Argument(help="Name of the function to extract")],
    melee_root: Annotated[
        Path, typer.Option("--melee-root", "-m", help="Path to melee submodule")
    ] = DEFAULT_MELEE_ROOT,
    output: Annotated[
        Optional[Path], typer.Option("--output", "-o", help="Output file for ASM")
    ] = None,
    full: Annotated[
        bool, typer.Option("--full", "-f", help="Show full assembly (no truncation)")
    ] = False,
):
    """Extract a specific function's ASM and context."""
    from src.extractor import extract_function

    func = asyncio.run(extract_function(melee_root, function_name))

    if func is None:
        console.print(f"[red]Function '{function_name}' not found[/red]")
        raise typer.Exit(1)

    console.print(f"[bold cyan]{func.name}[/bold cyan]")
    console.print(f"File: {func.file_path}")
    console.print(f"Address: {func.address}")
    console.print(f"Size: {func.size_bytes} bytes")
    console.print(f"Match: {func.current_match * 100:.1f}%")
    console.print("\n[bold]Assembly:[/bold]")
    if func.asm:
        if full or len(func.asm) <= 4000:
            console.print(func.asm)
        else:
            console.print(func.asm[:4000] + f"\n... ({len(func.asm) - 4000} more chars, use --full to see all)")
    else:
        console.print("[yellow]ASM not available (project needs to be built first)[/yellow]")

    if output:
        if func.asm:
            output.write_text(func.asm)
            console.print(f"\n[green]ASM written to {output}[/green]")
        else:
            console.print("[red]Cannot write output - ASM not available[/red]")


# ============================================================================
# Scratch Commands
# ============================================================================

scratch_app = typer.Typer(help="Manage decomp.me scratches")
app.add_typer(scratch_app, name="scratch")


@scratch_app.command("create")
def scratch_create(
    function_name: Annotated[str, typer.Argument(help="Name of the function")],
    melee_root: Annotated[
        Path, typer.Option("--melee-root", "-m", help="Path to melee submodule")
    ] = DEFAULT_MELEE_ROOT,
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
    context_file: Annotated[
        Optional[Path], typer.Option("--context", "-c", help="Path to context file (default: melee/build/ctx.c)")
    ] = None,
):
    """Create a new scratch for a function on decomp.me."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient
    from src.extractor import extract_function

    # Load context from file
    ctx_path = context_file or DEFAULT_CONTEXT_FILE
    if not ctx_path.exists():
        console.print(f"[red]Context file not found: {ctx_path}[/red]")
        console.print("[dim]Run 'ninja' in melee/ to generate build/ctx.c[/dim]")
        raise typer.Exit(1)

    melee_context = ctx_path.read_text()
    console.print(f"[dim]Loaded {len(melee_context):,} bytes of context from {ctx_path}[/dim]")

    async def create():
        func = await extract_function(melee_root, function_name)
        if func is None:
            console.print(f"[red]Function '{function_name}' not found[/red]")
            raise typer.Exit(1)

        async with DecompMeAPIClient(base_url=api_url) as client:
            from src.client import ScratchCreate
            scratch = await client.create_scratch(
                ScratchCreate(
                    name=func.name,
                    target_asm=func.asm,
                    context=melee_context,
                    compiler="mwcc_233_163n",
                    compiler_flags="-O4,p -nodefaults -fp hard -Cpp_exceptions off -enum int -fp_contract on -inline auto",
                    source_code="// TODO: Decompile this function\n",
                    diff_label=func.name,
                )
            )

            # Save claim token and claim ownership
            if scratch.claim_token:
                _save_scratch_token(scratch.slug, scratch.claim_token)
                try:
                    await client.claim_scratch(scratch.slug, scratch.claim_token)
                    console.print(f"[dim]Claimed ownership of scratch[/dim]")
                except Exception as e:
                    console.print(f"[yellow]Warning: Could not claim scratch: {e}[/yellow]")
            else:
                console.print(f"[yellow]Warning: No claim token received[/yellow]")

        return scratch

    scratch = asyncio.run(create())
    console.print(f"[green]Created scratch:[/green] {api_url}/scratch/{scratch.slug}")


@scratch_app.command("compile")
def scratch_compile(
    slug: Annotated[str, typer.Argument(help="Scratch slug/ID")],
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
):
    """Compile a scratch and show the diff."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient

    async def compile_scratch():
        async with DecompMeAPIClient(base_url=api_url) as client:
            result = await client.compile_scratch(slug)
            return result

    result = asyncio.run(compile_scratch())

    if result.success:
        match_pct = (
            100.0 if result.diff_output.current_score == 0
            else (1.0 - result.diff_output.current_score / result.diff_output.max_score) * 100
        )
        console.print(f"[green]Compiled successfully![/green]")
        console.print(f"Match: {match_pct:.1f}%")
        console.print(f"Score: {result.diff_output.current_score}/{result.diff_output.max_score}")
    else:
        console.print(f"[red]Compilation failed[/red]")
        console.print(result.compiler_output)


@scratch_app.command("update")
def scratch_update(
    slug: Annotated[str, typer.Argument(help="Scratch slug/ID")],
    source_file: Annotated[Path, typer.Argument(help="Path to C source file")],
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
):
    """Update a scratch's source code from a file."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient, ScratchUpdate, DecompMeAPIError

    source_code = source_file.read_text()

    async def update():
        async with DecompMeAPIClient(base_url=api_url) as client:
            try:
                scratch = await client.update_scratch(slug, ScratchUpdate(source_code=source_code))
            except DecompMeAPIError as e:
                if "403" in str(e):
                    # Try to re-claim with saved token
                    tokens = _load_scratch_tokens()
                    if slug in tokens:
                        console.print("[dim]Session mismatch, re-claiming with saved token...[/dim]")
                        try:
                            await client.claim_scratch(slug, tokens[slug])
                            scratch = await client.update_scratch(slug, ScratchUpdate(source_code=source_code))
                        except Exception:
                            raise e  # Re-raise original error
                    else:
                        console.print("[red]No saved token for this scratch - cannot update[/red]")
                        console.print("[dim]Create a new scratch with 'melee-agent scratch create'[/dim]")
                        raise typer.Exit(1)
                else:
                    raise
            result = await client.compile_scratch(slug)
            return scratch, result

    scratch, result = asyncio.run(update())

    if result.success and result.diff_output:
        match_pct = (
            100.0 if result.diff_output.current_score == 0
            else (1.0 - result.diff_output.current_score / result.diff_output.max_score) * 100
        )
        console.print(f"[green]Updated and compiled![/green] Match: {match_pct:.1f}%")
    else:
        console.print(f"[yellow]Updated but compilation failed[/yellow]")


@scratch_app.command("get")
def scratch_get(
    slug: Annotated[str, typer.Argument(help="Scratch slug/ID or URL")],
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """Get full scratch information including source code and target assembly."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient

    # Extract slug from URL if needed
    if slug.startswith("http"):
        parts = slug.strip("/").split("/")
        if "scratch" in parts:
            idx = parts.index("scratch")
            if idx + 1 < len(parts):
                slug = parts[idx + 1]

    async def get():
        async with DecompMeAPIClient(base_url=api_url) as client:
            return await client.get_scratch(slug)

    scratch = asyncio.run(get())

    if output_json:
        data = {
            "slug": scratch.slug,
            "name": scratch.name,
            "platform": scratch.platform,
            "compiler": scratch.compiler,
            "compiler_flags": scratch.compiler_flags,
            "score": scratch.score,
            "max_score": scratch.max_score,
            "match_percent": ((scratch.max_score - scratch.score) / scratch.max_score * 100) if scratch.max_score > 0 else 0,
            "source_code": scratch.source_code,
            "context": scratch.context[:1000] + "..." if len(scratch.context) > 1000 else scratch.context,
        }
        print(json.dumps(data, indent=2))
    else:
        match_pct = ((scratch.max_score - scratch.score) / scratch.max_score * 100) if scratch.max_score > 0 else 0
        console.print(f"[bold cyan]{scratch.name}[/bold cyan] ({scratch.slug})")
        console.print(f"Platform: {scratch.platform}")
        console.print(f"Compiler: {scratch.compiler}")
        console.print(f"Match: {match_pct:.1f}% (score: {scratch.score}/{scratch.max_score})")
        console.print(f"\n[bold]Source Code:[/bold]")
        console.print(scratch.source_code[:2000] if len(scratch.source_code) > 2000 else scratch.source_code)
        if len(scratch.source_code) > 2000:
            console.print(f"[dim]... ({len(scratch.source_code) - 2000} more chars)[/dim]")


@scratch_app.command("search")
def scratch_search(
    query: Annotated[Optional[str], typer.Argument(help="Search query")] = None,
    platform: Annotated[
        Optional[str], typer.Option("--platform", "-p", help="Filter by platform (e.g., gc_wii)")
    ] = None,
    min_match: Annotated[
        Optional[float], typer.Option("--min-match", help="Minimum match percentage")
    ] = None,
    max_match: Annotated[
        Optional[float], typer.Option("--max-match", help="Maximum match percentage")
    ] = None,
    incomplete: Annotated[
        bool, typer.Option("--incomplete", help="Only show incomplete scratches")
    ] = False,
    limit: Annotated[
        int, typer.Option("--limit", "-n", help="Maximum results")
    ] = 10,
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """Search for scratches on decomp.me."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient

    async def search():
        async with DecompMeAPIClient(base_url=api_url) as client:
            return await client.list_scratches(
                platform=platform,
                search=query,
                page_size=100,  # Fetch more for filtering
            )

    scratches = asyncio.run(search())

    # Filter by match percentage
    filtered = []
    for s in scratches:
        if s.max_score > 0:
            match_pct = (s.max_score - s.score) / s.max_score * 100
        else:
            match_pct = 100.0 if s.score == 0 else 0.0

        if incomplete and s.score == 0:
            continue
        if min_match is not None and match_pct < min_match:
            continue
        if max_match is not None and match_pct > max_match:
            continue

        filtered.append((s, match_pct))

    filtered = filtered[:limit]

    if output_json:
        data = [
            {
                "slug": s.slug,
                "name": s.name,
                "platform": s.platform,
                "compiler": s.compiler,
                "match_percent": mp,
                "score": s.score,
                "max_score": s.max_score,
            }
            for s, mp in filtered
        ]
        print(json.dumps(data, indent=2))
    else:
        table = Table(title="Scratches")
        table.add_column("Slug", style="cyan")
        table.add_column("Name", style="green")
        table.add_column("Platform")
        table.add_column("Match %", justify="right")

        for s, mp in filtered:
            table.add_row(s.slug, s.name, s.platform, f"{mp:.1f}%")

        console.print(table)
        console.print(f"[dim]Found {len(filtered)} scratches[/dim]")


@scratch_app.command("search-context")
def scratch_search_context(
    slug: Annotated[str, typer.Argument(help="Scratch slug/ID")],
    pattern: Annotated[str, typer.Argument(help="Regex pattern to search for")],
    context_lines: Annotated[
        int, typer.Option("--context", "-C", help="Context lines around matches")
    ] = 3,
    max_results: Annotated[
        int, typer.Option("--max", "-n", help="Maximum matches")
    ] = 20,
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """Search through a scratch's context (header files) for patterns."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient

    async def get():
        async with DecompMeAPIClient(base_url=api_url) as client:
            return await client.get_scratch(slug)

    scratch = asyncio.run(get())
    context = scratch.context

    if not context:
        console.print("[yellow]No context found for this scratch[/yellow]")
        raise typer.Exit(1)

    # Search for matches
    try:
        regex = re.compile(pattern, re.IGNORECASE)
    except re.error as e:
        console.print(f"[red]Invalid regex: {e}[/red]")
        raise typer.Exit(1)

    lines = context.splitlines()
    matches = []

    for i, line in enumerate(lines):
        if regex.search(line):
            start = max(0, i - context_lines)
            end = min(len(lines), i + context_lines + 1)
            matches.append({
                "line_num": i + 1,
                "matched_line": line,
                "context": lines[start:end],
                "context_start": start + 1,
            })
            if len(matches) >= max_results:
                break

    if output_json:
        print(json.dumps(matches, indent=2))
    else:
        if not matches:
            console.print(f"[yellow]No matches found for pattern: {pattern}[/yellow]")
            return

        console.print(f"[bold]Found {len(matches)} matches for:[/bold] {pattern}\n")

        for idx, match in enumerate(matches, 1):
            console.print(f"[bold cyan]Match {idx}[/bold cyan] (line {match['line_num']})")
            for line_idx, line_content in enumerate(match["context"]):
                line_num = match["context_start"] + line_idx
                marker = ">>> " if line_num == match["line_num"] else "    "
                console.print(f"{marker}{line_num:5d}: {line_content}")
            console.print()


# ============================================================================
# Claim Commands (parallel agent coordination)
# ============================================================================

def _load_claims() -> dict[str, Any]:
    """Load claims from file, removing stale entries."""
    claims_path = Path(DECOMP_CLAIMS_FILE)
    if not claims_path.exists():
        return {}

    try:
        with open(claims_path, 'r') as f:
            claims = json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}

    # Remove stale claims
    now = time.time()
    return {
        name: info for name, info in claims.items()
        if now - info.get("timestamp", 0) < DECOMP_CLAIM_TIMEOUT
    }


def _save_claims(claims: dict[str, Any]) -> None:
    """Save claims to file."""
    claims_path = Path(DECOMP_CLAIMS_FILE)
    claims_path.parent.mkdir(parents=True, exist_ok=True)
    with open(claims_path, 'w') as f:
        json.dump(claims, f, indent=2)


def _load_completed() -> dict[str, Any]:
    """Load completed functions from file."""
    completed_path = Path(DECOMP_COMPLETED_FILE)
    if not completed_path.exists():
        return {}

    try:
        with open(completed_path, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}


def _save_completed(completed: dict[str, Any]) -> None:
    """Save completed functions to file."""
    completed_path = Path(DECOMP_COMPLETED_FILE)
    completed_path.parent.mkdir(parents=True, exist_ok=True)
    with open(completed_path, 'w') as f:
        json.dump(completed, f, indent=2)


claim_app = typer.Typer(help="Manage function claims for parallel agents")
app.add_typer(claim_app, name="claim")


@claim_app.command("add")
def claim_add(
    function_name: Annotated[str, typer.Argument(help="Function name to claim")],
    agent_id: Annotated[
        str, typer.Option("--agent-id", help="Agent identifier")
    ] = "cli",
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """Claim a function to prevent other agents from working on it."""
    # Check if already completed
    completed = _load_completed()
    if function_name in completed:
        info = completed[function_name]
        if output_json:
            print(json.dumps({"success": False, "error": "already_completed", "info": info}))
        else:
            console.print(f"[red]Function already completed:[/red] {info.get('match_percent', 0):.1f}% match")
        raise typer.Exit(1)

    claims_path = Path(DECOMP_CLAIMS_FILE)
    claims_path.parent.mkdir(parents=True, exist_ok=True)
    lock_path = Path(str(claims_path) + ".lock")
    lock_path.touch(exist_ok=True)

    with open(lock_path, 'r') as lock_file:
        try:
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX)
            claims = _load_claims()

            if function_name in claims:
                existing = claims[function_name]
                age_mins = (time.time() - existing["timestamp"]) / 60
                if output_json:
                    print(json.dumps({"success": False, "error": "already_claimed", "by": existing.get("agent_id"), "age_mins": age_mins}))
                else:
                    console.print(f"[red]Already claimed by {existing.get('agent_id')} ({age_mins:.0f}m ago)[/red]")
                raise typer.Exit(1)

            claims[function_name] = {"agent_id": agent_id, "timestamp": time.time()}
            _save_claims(claims)

            if output_json:
                print(json.dumps({"success": True, "function": function_name}))
            else:
                console.print(f"[green]Claimed:[/green] {function_name}")
        finally:
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)


@claim_app.command("release")
def claim_release(
    function_name: Annotated[str, typer.Argument(help="Function name to release")],
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """Release a claimed function."""
    claims_path = Path(DECOMP_CLAIMS_FILE)
    if not claims_path.exists():
        if output_json:
            print(json.dumps({"success": False, "error": "not_claimed"}))
        else:
            console.print(f"[yellow]Function was not claimed[/yellow]")
        return

    lock_path = Path(str(claims_path) + ".lock")
    lock_path.touch(exist_ok=True)

    with open(lock_path, 'r') as lock_file:
        try:
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX)
            claims = _load_claims()

            if function_name not in claims:
                if output_json:
                    print(json.dumps({"success": False, "error": "not_claimed"}))
                else:
                    console.print(f"[yellow]Function was not claimed[/yellow]")
                return

            del claims[function_name]
            _save_claims(claims)

            if output_json:
                print(json.dumps({"success": True, "function": function_name}))
            else:
                console.print(f"[green]Released:[/green] {function_name}")
        finally:
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)


@claim_app.command("list")
def claim_list(
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """List all currently claimed functions."""
    claims = _load_claims()

    if output_json:
        print(json.dumps(claims, indent=2))
    else:
        if not claims:
            console.print("[dim]No functions currently claimed[/dim]")
            return

        table = Table(title="Claimed Functions")
        table.add_column("Function", style="cyan")
        table.add_column("Agent")
        table.add_column("Age", justify="right")
        table.add_column("Remaining", justify="right")

        now = time.time()
        for name, info in sorted(claims.items()):
            age_mins = (now - info["timestamp"]) / 60
            remaining_mins = (DECOMP_CLAIM_TIMEOUT / 60) - age_mins
            table.add_row(name, info.get("agent_id", "?"), f"{age_mins:.0f}m", f"{remaining_mins:.0f}m")

        console.print(table)


# ============================================================================
# Complete Commands (track completed functions)
# ============================================================================

complete_app = typer.Typer(help="Track completed/attempted functions")
app.add_typer(complete_app, name="complete")


@complete_app.command("mark")
def complete_mark(
    function_name: Annotated[str, typer.Argument(help="Function name")],
    scratch_slug: Annotated[str, typer.Argument(help="Decomp.me scratch slug")],
    match_percent: Annotated[float, typer.Argument(help="Match percentage achieved")],
    committed: Annotated[
        bool, typer.Option("--committed", help="Mark as committed to repo")
    ] = False,
    notes: Annotated[
        Optional[str], typer.Option("--notes", help="Additional notes")
    ] = None,
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """Mark a function as completed/attempted."""
    completed = _load_completed()
    completed[function_name] = {
        "match_percent": match_percent,
        "scratch_slug": scratch_slug,
        "committed": committed,
        "notes": notes or "",
        "timestamp": time.time(),
    }
    _save_completed(completed)

    # Also release any claim
    claims_path = Path(DECOMP_CLAIMS_FILE)
    if claims_path.exists():
        lock_path = Path(str(claims_path) + ".lock")
        lock_path.touch(exist_ok=True)
        with open(lock_path, 'r') as lock_file:
            try:
                fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX)
                claims = _load_claims()
                if function_name in claims:
                    del claims[function_name]
                    _save_claims(claims)
            finally:
                fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)

    if output_json:
        print(json.dumps({"success": True, "function": function_name, "match_percent": match_percent}))
    else:
        status = "committed" if committed else "recorded"
        console.print(f"[green]Completed ({status}):[/green] {function_name} at {match_percent:.1f}%")


@complete_app.command("list")
def complete_list(
    min_match: Annotated[
        float, typer.Option("--min-match", help="Minimum match percentage")
    ] = 0.0,
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """List all completed/attempted functions."""
    completed = _load_completed()

    # Filter by min_match
    filtered = {
        name: info for name, info in completed.items()
        if info.get("match_percent", 0) >= min_match
    }

    if output_json:
        print(json.dumps(filtered, indent=2))
    else:
        if not filtered:
            console.print("[dim]No completed functions found[/dim]")
            return

        table = Table(title="Completed Functions")
        table.add_column("Function", style="cyan")
        table.add_column("Match %", justify="right")
        table.add_column("Scratch")
        table.add_column("Status")
        table.add_column("Notes", style="dim")

        sorted_funcs = sorted(filtered.items(), key=lambda x: -x[1].get("match_percent", 0))
        for name, info in sorted_funcs:
            status = "[green]✓[/green]" if info.get("committed") else "[yellow]○[/yellow]"
            table.add_row(
                name,
                f"{info.get('match_percent', 0):.1f}%",
                info.get("scratch_slug", "?"),
                status,
                info.get("notes", "")[:30],
            )

        console.print(table)


# ============================================================================
# Compilers Command
# ============================================================================

@app.command("compilers")
def list_compilers(
    platform: Annotated[
        Optional[str], typer.Argument(help="Filter by platform (e.g., gc_wii)")
    ] = None,
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
    output_json: Annotated[
        bool, typer.Option("--json", help="Output as JSON")
    ] = False,
):
    """List available compilers."""
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient

    async def get():
        async with DecompMeAPIClient(base_url=api_url) as client:
            return await client.list_compilers()

    compilers = asyncio.run(get())

    if platform:
        compilers = [c for c in compilers if c.platform == platform]

    if output_json:
        data = [{"id": c.id, "name": c.name, "platform": c.platform, "language": c.language} for c in compilers]
        print(json.dumps(data, indent=2))
    else:
        table = Table(title="Available Compilers")
        table.add_column("ID", style="cyan")
        table.add_column("Name")
        table.add_column("Platform")
        table.add_column("Language")

        for c in compilers:
            table.add_row(c.id, c.name, c.platform, c.language)

        console.print(table)
        console.print(f"[dim]{len(compilers)} compilers available[/dim]")


# ============================================================================
# Commit Commands
# ============================================================================

commit_app = typer.Typer(help="Commit matched functions and create PRs")
app.add_typer(commit_app, name="commit")


@commit_app.command("apply")
def commit_apply(
    function_name: Annotated[str, typer.Argument(help="Name of the matched function")],
    scratch_slug: Annotated[str, typer.Argument(help="Decomp.me scratch slug")],
    melee_root: Annotated[
        Path, typer.Option("--melee-root", "-m", help="Path to melee submodule")
    ] = DEFAULT_MELEE_ROOT,
    api_url: Annotated[
        str, typer.Option("--api-url", help="Decomp.me API URL")
    ] = DEFAULT_DECOMP_ME_URL,
    create_pr: Annotated[
        bool, typer.Option("--pr", help="Create a PR after committing")
    ] = False,
    full_code: Annotated[
        bool, typer.Option("--full-code", help="Use full scratch code (including struct defs)")
    ] = False,
    min_match: Annotated[
        float, typer.Option("--min-match", help="Minimum match percentage (default: 95.0)")
    ] = 95.0,
    force: Annotated[
        bool, typer.Option("--force", "-f", help="Force commit even if below min-match threshold")
    ] = False,
    dry_run: Annotated[
        bool, typer.Option("--dry-run", help="Show what would be changed without applying")
    ] = False,
):
    """Apply a matched function to the melee project.

    By default, extracts just the function body from the scratch code,
    discarding any helper struct definitions. Use --full-code to include
    the complete scratch code (useful when new types are needed).

    Use --min-match to adjust the minimum match percentage (default: 95%).
    Use --force to bypass the match check entirely (use with caution).
    Use --dry-run to preview changes and verify compilation without modifying files.
    """
    _require_api_url(api_url)
    from src.client import DecompMeAPIClient
    from src.commit import auto_detect_and_commit
    from src.commit.configure import get_file_path_from_function
    from src.commit.update import validate_function_code, _extract_function_from_code

    async def apply():
        async with DecompMeAPIClient(base_url=api_url) as client:
            scratch = await client.get_scratch(scratch_slug)

            # Calculate match percentage
            if scratch.max_score > 0:
                match_pct = (scratch.max_score - scratch.score) / scratch.max_score * 100
            else:
                match_pct = 100.0 if scratch.score == 0 else 0.0

            # Verify it meets the minimum match requirement
            if match_pct < min_match and not force:
                console.print(f"[red]Scratch is only {match_pct:.1f}% match (minimum: {min_match:.1f}%)[/red]")
                console.print("[dim]Use --force to bypass this check, or --min-match to adjust threshold[/dim]")
                raise typer.Exit(1)

            if scratch.score != 0:
                if force and match_pct < min_match:
                    console.print(f"[yellow]⚠ Forcing commit at {match_pct:.1f}% match (below {min_match:.1f}% threshold)[/yellow]")
                else:
                    console.print(f"[yellow]Note: Scratch is {match_pct:.1f}% match (not 100%)[/yellow]")

            # Dry-run mode: preview changes and verify compilation
            if dry_run:
                console.print("\n[bold cyan]DRY RUN MODE[/bold cyan] - No files will be modified\n")

                # Find the target file
                file_path = await get_file_path_from_function(function_name, melee_root)
                if not file_path:
                    console.print(f"[red]Could not find file containing function '{function_name}'[/red]")
                    raise typer.Exit(1)

                console.print(f"[bold]Target file:[/bold] src/{file_path}")

                # Process the code the same way the workflow would
                source_code = scratch.source_code.strip()
                if not full_code:
                    extracted = _extract_function_from_code(source_code, function_name)
                    if extracted:
                        source_code = extracted

                # Validate the code
                is_valid, msg = validate_function_code(source_code, function_name)
                if not is_valid:
                    console.print(f"[red]Code validation failed:[/red] {msg}")
                    raise typer.Exit(1)
                if msg:
                    console.print(f"[yellow]{msg}[/yellow]")
                else:
                    console.print("[green]✓ Code validation passed[/green]")

                # Show code preview
                console.print(f"\n[bold]Code to insert ({len(source_code)} chars):[/bold]")
                preview_lines = source_code.split('\n')
                if len(preview_lines) > 20:
                    for line in preview_lines[:10]:
                        console.print(f"  {line}")
                    console.print(f"  [dim]... ({len(preview_lines) - 20} more lines) ...[/dim]")
                    for line in preview_lines[-10:]:
                        console.print(f"  {line}")
                else:
                    for line in preview_lines:
                        console.print(f"  {line}")

                # Test compilation by temporarily applying and reverting
                console.print("\n[bold]Testing compilation...[/bold]")
                full_path = melee_root / "src" / file_path
                original_content = full_path.read_text(encoding='utf-8')

                try:
                    # Temporarily apply the change
                    from src.commit.update import update_source_file
                    success = await update_source_file(
                        file_path, function_name, source_code, melee_root,
                        extract_function_only=False  # Already extracted above
                    )
                    if not success:
                        console.print("[red]Failed to apply code (validation or insertion error)[/red]")
                        raise typer.Exit(1)

                    # Try to compile
                    import subprocess
                    # Run configure.py first
                    subprocess.run(
                        ["python", "configure.py"],
                        cwd=melee_root, capture_output=True
                    )
                    # Compile the object file
                    obj_path = f"build/GALE01/src/{file_path}".replace('.c', '.o')
                    result = subprocess.run(
                        ["ninja", obj_path],
                        cwd=melee_root, capture_output=True, text=True
                    )

                    if result.returncode == 0:
                        console.print("[green]✓ Compilation successful[/green]")
                    else:
                        console.print("[red]✗ Compilation failed:[/red]")
                        # Extract error lines
                        for line in result.stderr.split('\n'):
                            if 'Error:' in line or 'error:' in line.lower():
                                console.print(f"  {line}")
                        raise typer.Exit(1)

                finally:
                    # Always revert to original
                    full_path.write_text(original_content, encoding='utf-8')
                    console.print("[dim]Reverted test changes[/dim]")

                console.print("\n[green bold]Dry run complete - all checks passed![/green bold]")
                console.print("[dim]Run without --dry-run to apply changes[/dim]")
                return None

            scratch_url = f"{api_url}/scratch/{scratch_slug}"
            pr_url = await auto_detect_and_commit(
                function_name=function_name,
                new_code=scratch.source_code,
                scratch_id=scratch_slug,
                scratch_url=scratch_url,
                melee_root=melee_root,
                author="agent",
                create_pull_request=create_pr,
                extract_function_only=not full_code,
            )
            return pr_url

    pr_url = asyncio.run(apply())

    if dry_run:
        return  # Already printed results

    console.print(f"[green]Applied {function_name}[/green]")

    if pr_url:
        console.print(f"\n[bold]PR created:[/bold] {pr_url}")


@commit_app.command("format")
def commit_format(
    melee_root: Annotated[
        Path, typer.Option("--melee-root", "-m", help="Path to melee submodule")
    ] = DEFAULT_MELEE_ROOT,
):
    """Run clang-format on staged changes."""
    from src.commit import format_files

    success = asyncio.run(format_files(melee_root))

    if success:
        console.print("[green]Formatting applied[/green]")
    else:
        console.print("[red]Formatting failed[/red]")
        raise typer.Exit(1)


# ============================================================================
# Docker Commands
# ============================================================================

docker_app = typer.Typer(help="Manage local decomp.me instance")
app.add_typer(docker_app, name="docker")


@docker_app.command("up")
def docker_up(
    port: Annotated[int, typer.Option("--port", "-p", help="API port")] = 8000,
    detach: Annotated[bool, typer.Option("--detach", "-d", help="Run in background")] = True,
):
    """Start local decomp.me instance."""
    import subprocess

    docker_dir = Path(__file__).parent.parent / "docker"
    env = {"DECOMP_ME_PORT": str(port)}

    cmd = ["docker", "compose", "-f", str(docker_dir / "docker-compose.yml"), "up"]
    if detach:
        cmd.append("-d")

    console.print(f"[cyan]Starting decomp.me on port {port}...[/cyan]")
    result = subprocess.run(cmd, env={**subprocess.os.environ, **env})

    if result.returncode == 0:
        console.print(f"[green]decomp.me running at http://localhost:{port}[/green]")
    else:
        console.print("[red]Failed to start decomp.me[/red]")
        raise typer.Exit(1)


@docker_app.command("down")
def docker_down():
    """Stop local decomp.me instance."""
    import subprocess

    docker_dir = Path(__file__).parent.parent / "docker"

    cmd = ["docker", "compose", "-f", str(docker_dir / "docker-compose.yml"), "down"]
    subprocess.run(cmd)
    console.print("[green]decomp.me stopped[/green]")


@docker_app.command("status")
def docker_status():
    """Check status of local decomp.me instance."""
    import subprocess

    docker_dir = Path(__file__).parent.parent / "docker"

    cmd = ["docker", "compose", "-f", str(docker_dir / "docker-compose.yml"), "ps"]
    subprocess.run(cmd)


if __name__ == "__main__":
    app()
