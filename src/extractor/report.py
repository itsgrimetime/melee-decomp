"""Parse report.json for function-level match data.

The report.json file is generated by objdiff-cli and contains per-function
fuzzy match percentages and other metadata.
"""

import json
from pathlib import Path
from typing import Optional
from .models import FunctionMatch


class ReportParser:
    """Parser for report.json to extract function match data.

    This is the authoritative source for match percentages in the decompilation
    project. The report.json is generated by objdiff-cli during the build process
    and reflects the actual state of decompiled code in the repository.

    To regenerate: ninja build/GALE01/report.json

    Note: No caching is used - report.json loads in ~50ms and caching would cause
    stale data issues when multiple agents work in parallel.
    """

    def __init__(self, melee_root: Path):
        """
        Initialize parser.

        Args:
            melee_root: Path to the melee project root directory
        """
        self.melee_root = Path(melee_root)
        self.report_path = self.melee_root / "build" / "GALE01" / "report.json"

    def parse_report(self) -> dict:
        """
        Parse report.json and return the complete structure.

        Returns:
            Dictionary containing the full report data

        Raises:
            FileNotFoundError: If report.json doesn't exist
        """
        if not self.report_path.exists():
            raise FileNotFoundError(
                f"report.json not found at {self.report_path}\n"
                "You may need to build the project first with: ninja build/GALE01/report.json"
            )

        with open(self.report_path, "r", encoding="utf-8") as f:
            return json.load(f)

    def get_function_matches(self) -> dict[str, FunctionMatch]:
        """
        Extract function-level match data from report.json.

        This is the authoritative source for match percentages. The report.json
        reflects the actual compiled state of code in the repository.

        Returns:
            Dictionary mapping function names to FunctionMatch objects
        """
        try:
            report = self.parse_report()
        except FileNotFoundError:
            # Return empty dict if report doesn't exist
            return {}

        function_matches = {}

        # Parse the report structure
        # The exact structure may vary, so we handle multiple potential formats
        if "units" in report:
            # Format: report.json has a "units" array
            for unit in report.get("units", []):
                unit_matches = self._extract_from_unit(unit)
                function_matches.update(unit_matches)

        elif "measures" in report:
            # Alternative format with measures
            for measure in report.get("measures", []):
                if "functions" in measure:
                    for func_data in measure["functions"]:
                        match = self._parse_function_data(func_data)
                        if match:
                            function_matches[match.name] = match

        # Check if report has direct function list
        if "functions" in report:
            for func_data in report["functions"]:
                match = self._parse_function_data(func_data)
                if match:
                    function_matches[match.name] = match

        return function_matches

    def get_report_age_seconds(self) -> Optional[float]:
        """Get the age of report.json in seconds.

        Returns:
            Age in seconds, or None if file doesn't exist
        """
        import time
        if not self.report_path.exists():
            return None
        return time.time() - self.report_path.stat().st_mtime

    def is_report_stale(self, max_age_hours: float = 24.0) -> bool:
        """Check if report.json might be stale.

        Args:
            max_age_hours: Consider stale if older than this many hours (default 24)

        Returns:
            True if report is older than max_age_hours or doesn't exist
        """
        age = self.get_report_age_seconds()
        if age is None:
            return True
        return age > (max_age_hours * 3600)

    def _extract_from_unit(self, unit: dict) -> dict[str, FunctionMatch]:
        """
        Extract function matches from a unit entry.

        Args:
            unit: Unit dictionary from report.json

        Returns:
            Dictionary mapping function names to FunctionMatch objects
        """
        matches = {}

        # Check for functions in unit
        if "functions" in unit:
            for func_data in unit["functions"]:
                match = self._parse_function_data(func_data)
                if match:
                    matches[match.name] = match

        # Check for sections with functions
        if "sections" in unit:
            for section in unit["sections"]:
                if "functions" in section:
                    for func_data in section["functions"]:
                        match = self._parse_function_data(func_data)
                        if match:
                            matches[match.name] = match

        return matches

    def _parse_function_data(self, func_data: dict) -> Optional[FunctionMatch]:
        """
        Parse function data into a FunctionMatch object.

        Args:
            func_data: Function dictionary from report.json

        Returns:
            FunctionMatch object or None if parsing fails
        """
        # Get function name
        name = func_data.get("name")
        if not name:
            # Try alternative name fields
            name = func_data.get("symbol") or func_data.get("function_name")

        if not name:
            return None

        # Get fuzzy match percentage
        # Try multiple possible field names
        fuzzy_match = None
        for field in ["fuzzy_match_percent", "match_percent", "fuzzy_match", "match"]:
            if field in func_data:
                fuzzy_match = func_data[field]
                break

        # Default to 0.0 if not found
        if fuzzy_match is None:
            fuzzy_match = 0.0

        # Ensure it's a float
        try:
            fuzzy_match = float(fuzzy_match)
        except (ValueError, TypeError):
            fuzzy_match = 0.0

        # Extract virtual_address from metadata and convert to hex
        address_hex = None
        metadata = func_data.get("metadata", {})
        virtual_address = metadata.get("virtual_address")
        if virtual_address:
            try:
                # virtual_address is a decimal string like "2147506496"
                addr_int = int(virtual_address)
                address_hex = f"0x{addr_int:08X}"
            except (ValueError, TypeError):
                pass

        return FunctionMatch(
            name=name,
            fuzzy_match_percent=fuzzy_match,
            address=address_hex,
        )

    def get_function_match(self, function_name: str) -> Optional[FunctionMatch]:
        """
        Get match data for a specific function.

        Args:
            function_name: Name of the function

        Returns:
            FunctionMatch if found, None otherwise
        """
        matches = self.get_function_matches()
        return matches.get(function_name)

    def get_overall_stats(self) -> dict:
        """
        Get overall statistics from the report.

        Returns:
            Dictionary with overall statistics
        """
        try:
            report = self.parse_report()
        except FileNotFoundError:
            return {
                "total_functions": 0,
                "matched_functions": 0,
                "average_match": 0.0,
            }

        # Extract overall stats if available
        stats = {
            "total_functions": report.get("total_functions", 0),
            "matched_functions": report.get("matched_functions", 0),
            "average_match": report.get("average_match", 0.0),
        }

        # If not directly available, calculate from function matches
        if stats["total_functions"] == 0:
            function_matches = self.get_function_matches()
            stats["total_functions"] = len(function_matches)
            stats["matched_functions"] = sum(
                1 for m in function_matches.values() if m.fuzzy_match_percent >= 100.0
            )
            if function_matches:
                stats["average_match"] = sum(
                    m.fuzzy_match_percent for m in function_matches.values()
                ) / len(function_matches)

        return stats


async def parse_report(melee_root: Path) -> dict[str, FunctionMatch]:
    """
    Async wrapper for parsing report.json.

    Args:
        melee_root: Path to the melee project root directory

    Returns:
        Dictionary mapping function names to FunctionMatch objects
    """
    parser = ReportParser(melee_root)
    return parser.get_function_matches()
